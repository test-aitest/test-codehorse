/**
 * Phase 10: Vulnerability Scanner
 *
 * ãƒ¡ã‚¤ãƒ³ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è„†å¼±æ€§ã‚¹ã‚­ãƒ£ãƒŠãƒ¼
 * å„æ¤œå‡ºå™¨ã‚’çµ±åˆã—ã¦åŒ…æ‹¬çš„ãªã‚¹ã‚­ãƒ£ãƒ³ã‚’å®Ÿè¡Œ
 */

import type {
  DetectedVulnerability,
  SecurityScanOptions,
  SecurityScanResult,
  SecurityScanStats,
  SecuritySeverityValue,
} from "./types";
import { DEFAULT_SECURITY_OPTIONS } from "./types";
import { detectSqlInjection } from "./sql-injection-detector";
import { detectXss } from "./xss-detector";
import { detectSecrets } from "./secret-detector";
import { analyzeAuth } from "./auth-analyzer";

// ========================================
// é‡è¦åº¦ã®å„ªå…ˆé †ä½
// ========================================

const SEVERITY_ORDER: Record<SecuritySeverityValue, number> = {
  CRITICAL: 4,
  HIGH: 3,
  MEDIUM: 2,
  LOW: 1,
};

// ========================================
// ãƒ¡ã‚¤ãƒ³ã‚¹ã‚­ãƒ£ãƒ³é–¢æ•°
// ========================================

/**
 * ã‚³ãƒ¼ãƒ‰ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è„†å¼±æ€§ã‚’ã‚¹ã‚­ãƒ£ãƒ³
 */
export function scanFile(
  code: string,
  filePath: string,
  options: SecurityScanOptions = {}
): DetectedVulnerability[] {
  const mergedOptions = { ...DEFAULT_SECURITY_OPTIONS, ...options };
  const vulnerabilities: DetectedVulnerability[] = [];

  // é™¤å¤–ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯
  if (shouldExcludeFile(filePath, mergedOptions.excludePatterns)) {
    return vulnerabilities;
  }

  const language = mergedOptions.language;

  // SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³æ¤œå‡º
  if (mergedOptions.detectSqlInjection) {
    vulnerabilities.push(...detectSqlInjection(code, filePath, language));
  }

  // XSSæ¤œå‡º
  if (mergedOptions.detectXss) {
    vulnerabilities.push(...detectXss(code, filePath, language));
  }

  // æ©Ÿå¯†æƒ…å ±æ¤œå‡º
  if (mergedOptions.detectSecrets) {
    vulnerabilities.push(...detectSecrets(code, filePath, language));
  }

  // èªè¨¼ãƒ»èªå¯å•é¡Œæ¤œå‡º
  if (mergedOptions.detectAuthIssues) {
    vulnerabilities.push(...analyzeAuth(code, filePath, language));
  }

  // æœ€å°é‡è¦åº¦ã§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
  const filtered = filterBySeverity(vulnerabilities, mergedOptions.minSeverity);

  // é‡è¤‡æ’é™¤
  const deduplicated = deduplicateVulnerabilities(filtered);

  // æœ€å¤§æ•°åˆ¶é™
  const limited = deduplicated.slice(0, mergedOptions.maxIssues);

  // é‡è¦åº¦ã§ã‚½ãƒ¼ãƒˆ
  return sortBySeverity(limited);
}

/**
 * è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¹ã‚­ãƒ£ãƒ³
 */
export function scanFiles(
  files: Array<{ path: string; content: string }>,
  options: SecurityScanOptions = {}
): SecurityScanResult {
  const startTime = Date.now();
  const allVulnerabilities: DetectedVulnerability[] = [];
  let filesScanned = 0;

  for (const file of files) {
    const vulnerabilities = scanFile(file.content, file.path, options);
    allVulnerabilities.push(...vulnerabilities);
    filesScanned++;
  }

  const scanTimeMs = Date.now() - startTime;
  const mergedOptions = { ...DEFAULT_SECURITY_OPTIONS, ...options };

  // æœ€å¤§æ•°åˆ¶é™
  const limited = allVulnerabilities.slice(0, mergedOptions.maxIssues);

  return {
    vulnerabilities: sortBySeverity(limited),
    filesScanned,
    scanTimeMs,
    stats: calculateStats(limited),
  };
}

/**
 * PRã®å¤‰æ›´ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¹ã‚­ãƒ£ãƒ³
 */
export function scanPullRequestChanges(
  changedFiles: Array<{ path: string; content: string; patch?: string }>,
  options: SecurityScanOptions = {}
): SecurityScanResult {
  const startTime = Date.now();
  const allVulnerabilities: DetectedVulnerability[] = [];
  let filesScanned = 0;

  for (const file of changedFiles) {
    // ãƒ‘ãƒƒãƒãŒã‚ã‚‹å ´åˆã¯å¤‰æ›´è¡Œã®ã¿ã‚’ãƒã‚§ãƒƒã‚¯å¯¾è±¡ã«ã™ã‚‹
    const changedLines = file.patch ? parseChangedLines(file.patch) : null;

    const vulnerabilities = scanFile(file.content, file.path, options);

    // å¤‰æ›´è¡Œã§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
    const filteredVulns = changedLines
      ? vulnerabilities.filter((v) => changedLines.has(v.lineNumber))
      : vulnerabilities;

    allVulnerabilities.push(...filteredVulns);
    filesScanned++;
  }

  const scanTimeMs = Date.now() - startTime;
  const mergedOptions = { ...DEFAULT_SECURITY_OPTIONS, ...options };

  // æœ€å¤§æ•°åˆ¶é™
  const limited = allVulnerabilities.slice(0, mergedOptions.maxIssues);

  return {
    vulnerabilities: sortBySeverity(limited),
    filesScanned,
    scanTimeMs,
    stats: calculateStats(limited),
  };
}

// ========================================
// ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
// ========================================

/**
 * ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é™¤å¤–ã™ã¹ãã‹ãƒã‚§ãƒƒã‚¯
 * ã‚·ãƒ³ãƒ—ãƒ«ãªglobãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ï¼ˆminimatchã®ä»£æ›¿ï¼‰
 */
function shouldExcludeFile(filePath: string, excludePatterns: string[]): boolean {
  return excludePatterns.some((pattern) => matchGlobPattern(filePath, pattern));
}

/**
 * ã‚·ãƒ³ãƒ—ãƒ«ãªglobãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°
 * ã‚µãƒãƒ¼ãƒˆ: *, **, ?(ä»»æ„ã®1æ–‡å­—)
 */
function matchGlobPattern(filePath: string, pattern: string): boolean {
  // ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ­£è¦è¡¨ç¾ã«å¤‰æ›
  const regexPattern = pattern
    // ç‰¹æ®Šæ–‡å­—ã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
    .replace(/[.+^${}()|[\]\\]/g, "\\$&")
    // ** ã¯ä»»æ„ã®ãƒ‘ã‚¹ã«ãƒãƒƒãƒ
    .replace(/\*\*/g, "{{DOUBLE_STAR}}")
    // * ã¯ä»»æ„ã®æ–‡å­—åˆ—ï¼ˆ/ã‚’é™¤ãï¼‰ã«ãƒãƒƒãƒ
    .replace(/\*/g, "[^/]*")
    // ** ã‚’å¾©å…ƒ
    .replace(/\{\{DOUBLE_STAR\}\}/g, ".*")
    // ? ã¯ä»»æ„ã®1æ–‡å­—ã«ãƒãƒƒãƒ
    .replace(/\?/g, ".");

  const regex = new RegExp(`^${regexPattern}$|/${regexPattern}$|^${regexPattern}/|/${regexPattern}/`);
  return regex.test(filePath);
}

/**
 * é‡è¦åº¦ã§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
 */
function filterBySeverity(
  vulnerabilities: DetectedVulnerability[],
  minSeverity: SecuritySeverityValue
): DetectedVulnerability[] {
  const minOrder = SEVERITY_ORDER[minSeverity];
  return vulnerabilities.filter((v) => SEVERITY_ORDER[v.severity] >= minOrder);
}

/**
 * é‡è¤‡æ’é™¤
 */
function deduplicateVulnerabilities(
  vulnerabilities: DetectedVulnerability[]
): DetectedVulnerability[] {
  const seen = new Set<string>();
  const result: DetectedVulnerability[] = [];

  for (const vuln of vulnerabilities) {
    // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã€è¡Œç•ªå·ã€ãƒ‘ã‚¿ãƒ¼ãƒ³IDã§é‡è¤‡ã‚’åˆ¤å®š
    const key = `${vuln.filePath}:${vuln.lineNumber}:${vuln.patternId || vuln.vulnerabilityType}`;
    if (!seen.has(key)) {
      seen.add(key);
      result.push(vuln);
    }
  }

  return result;
}

/**
 * é‡è¦åº¦ã§ã‚½ãƒ¼ãƒˆ
 */
function sortBySeverity(
  vulnerabilities: DetectedVulnerability[]
): DetectedVulnerability[] {
  return [...vulnerabilities].sort((a, b) => {
    const orderA = SEVERITY_ORDER[a.severity];
    const orderB = SEVERITY_ORDER[b.severity];
    if (orderA !== orderB) {
      return orderB - orderA; // é™é †
    }
    // åŒã˜é‡è¦åº¦ã®å ´åˆã¯ãƒ•ã‚¡ã‚¤ãƒ«åã¨è¡Œç•ªå·ã§ã‚½ãƒ¼ãƒˆ
    if (a.filePath !== b.filePath) {
      return a.filePath.localeCompare(b.filePath);
    }
    return a.lineNumber - b.lineNumber;
  });
}

/**
 * çµ±è¨ˆæƒ…å ±ã‚’è¨ˆç®—
 */
function calculateStats(
  vulnerabilities: DetectedVulnerability[]
): SecurityScanStats {
  const bySeverity: Record<SecuritySeverityValue, number> = {
    CRITICAL: 0,
    HIGH: 0,
    MEDIUM: 0,
    LOW: 0,
  };

  const byType: Record<string, number> = {};
  const byFile: Record<string, number> = {};

  for (const vuln of vulnerabilities) {
    bySeverity[vuln.severity]++;
    byType[vuln.vulnerabilityType] = (byType[vuln.vulnerabilityType] || 0) + 1;
    byFile[vuln.filePath] = (byFile[vuln.filePath] || 0) + 1;
  }

  return { bySeverity, byType, byFile };
}

/**
 * ãƒ‘ãƒƒãƒã‹ã‚‰å¤‰æ›´è¡Œã‚’è§£æ
 */
function parseChangedLines(patch: string): Set<number> {
  const changedLines = new Set<number>();
  const lines = patch.split("\n");

  let currentLine = 0;

  for (const line of lines) {
    // @@ -start,count +start,count @@ ã®å½¢å¼
    const hunkMatch = line.match(/@@ -\d+(?:,\d+)? \+(\d+)(?:,\d+)? @@/);
    if (hunkMatch) {
      currentLine = parseInt(hunkMatch[1], 10);
      continue;
    }

    if (line.startsWith("+") && !line.startsWith("+++")) {
      // è¿½åŠ ã•ã‚ŒãŸè¡Œ
      changedLines.add(currentLine);
      currentLine++;
    } else if (line.startsWith("-") && !line.startsWith("---")) {
      // å‰Šé™¤ã•ã‚ŒãŸè¡Œï¼ˆã‚«ã‚¦ãƒ³ãƒˆã—ãªã„ï¼‰
      continue;
    } else if (!line.startsWith("\\")) {
      // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆè¡Œ
      currentLine++;
    }
  }

  return changedLines;
}

// ========================================
// ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
// ========================================

/**
 * ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³å½¢å¼ã®ãƒ¬ãƒãƒ¼ãƒˆã‚’ç”Ÿæˆ
 */
export function generateMarkdownReport(
  result: SecurityScanResult,
  language: "ja" | "en" = "ja"
): string {
  const { vulnerabilities, filesScanned, scanTimeMs, stats } = result;

  const title = language === "ja" ? "ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³ãƒ¬ãƒãƒ¼ãƒˆ" : "Security Scan Report";
  const summaryTitle = language === "ja" ? "æ¦‚è¦" : "Summary";
  const statsTitle = language === "ja" ? "é‡è¦åº¦åˆ¥" : "By Severity";
  const findingsTitle = language === "ja" ? "æ¤œå‡ºã•ã‚ŒãŸè„†å¼±æ€§" : "Detected Vulnerabilities";
  const noIssuesText =
    language === "ja"
      ? "ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã®å•é¡Œã¯æ¤œå‡ºã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚"
      : "No security issues detected.";

  let report = `# ğŸ”’ ${title}\n\n`;

  // æ¦‚è¦
  report += `## ${summaryTitle}\n\n`;
  report += `- ${language === "ja" ? "ã‚¹ã‚­ãƒ£ãƒ³ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«æ•°" : "Files scanned"}: ${filesScanned}\n`;
  report += `- ${language === "ja" ? "æ¤œå‡ºã•ã‚ŒãŸè„†å¼±æ€§" : "Vulnerabilities found"}: ${vulnerabilities.length}\n`;
  report += `- ${language === "ja" ? "ã‚¹ã‚­ãƒ£ãƒ³æ™‚é–“" : "Scan time"}: ${scanTimeMs}ms\n\n`;

  // é‡è¦åº¦åˆ¥çµ±è¨ˆ
  report += `### ${statsTitle}\n\n`;
  report += `| ${language === "ja" ? "é‡è¦åº¦" : "Severity"} | ${language === "ja" ? "ä»¶æ•°" : "Count"} |\n`;
  report += "|----------|-------|\n";
  report += `| ğŸ”´ CRITICAL | ${stats.bySeverity.CRITICAL} |\n`;
  report += `| ğŸŸ  HIGH | ${stats.bySeverity.HIGH} |\n`;
  report += `| ğŸŸ¡ MEDIUM | ${stats.bySeverity.MEDIUM} |\n`;
  report += `| ğŸŸ¢ LOW | ${stats.bySeverity.LOW} |\n\n`;

  // è„†å¼±æ€§ä¸€è¦§
  if (vulnerabilities.length === 0) {
    report += `âœ… ${noIssuesText}\n`;
  } else {
    report += `## ${findingsTitle}\n\n`;

    for (const vuln of vulnerabilities) {
      const severityEmoji = getSeverityEmoji(vuln.severity);
      report += `### ${severityEmoji} ${vuln.vulnerabilityType}\n\n`;
      report += `- **${language === "ja" ? "ãƒ•ã‚¡ã‚¤ãƒ«" : "File"}**: \`${vuln.filePath}:${vuln.lineNumber}\`\n`;
      if (vuln.cweId) {
        report += `- **CWE**: [${vuln.cweId}](https://cwe.mitre.org/data/definitions/${vuln.cweId.replace("CWE-", "")}.html)\n`;
      }
      if (vuln.owaspCategory) {
        report += `- **OWASP**: ${vuln.owaspCategory}\n`;
      }
      report += `- **${language === "ja" ? "èª¬æ˜" : "Description"}**: ${vuln.description}\n`;
      if (vuln.remediation) {
        report += `- **${language === "ja" ? "ä¿®æ­£æ–¹æ³•" : "Remediation"}**: ${vuln.remediation}\n`;
      }
      if (vuln.codeSnippet) {
        report += `\n\`\`\`\n${vuln.codeSnippet}\n\`\`\`\n`;
      }
      report += "\n---\n\n";
    }
  }

  return report;
}

/**
 * é‡è¦åº¦ã«å¿œã˜ãŸçµµæ–‡å­—ã‚’å–å¾—
 */
function getSeverityEmoji(severity: SecuritySeverityValue): string {
  switch (severity) {
    case "CRITICAL":
      return "ğŸ”´";
    case "HIGH":
      return "ğŸŸ ";
    case "MEDIUM":
      return "ğŸŸ¡";
    case "LOW":
      return "ğŸŸ¢";
    default:
      return "âšª";
  }
}

/**
 * çµæœã‚’JSONå½¢å¼ã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
 */
export function exportToJson(result: SecurityScanResult): string {
  return JSON.stringify(result, null, 2);
}

/**
 * SARIFå½¢å¼ã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆï¼ˆGitHub Code Scanningå¯¾å¿œï¼‰
 */
export function exportToSarif(result: SecurityScanResult): object {
  return {
    $schema: "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
    version: "2.1.0",
    runs: [
      {
        tool: {
          driver: {
            name: "CodeHorse Security Scanner",
            version: "1.0.0",
            informationUri: "https://codehorse.dev",
            rules: generateSarifRules(result.vulnerabilities),
          },
        },
        results: result.vulnerabilities.map((vuln) => ({
          ruleId: vuln.patternId || vuln.vulnerabilityType,
          level: mapSeverityToSarifLevel(vuln.severity),
          message: {
            text: vuln.description,
          },
          locations: [
            {
              physicalLocation: {
                artifactLocation: {
                  uri: vuln.filePath,
                },
                region: {
                  startLine: vuln.lineNumber,
                  endLine: vuln.endLineNumber || vuln.lineNumber,
                },
              },
            },
          ],
        })),
      },
    ],
  };
}

/**
 * SARIFãƒ«ãƒ¼ãƒ«ã‚’ç”Ÿæˆ
 */
function generateSarifRules(vulnerabilities: DetectedVulnerability[]): object[] {
  const rules = new Map<string, object>();

  for (const vuln of vulnerabilities) {
    const ruleId = vuln.patternId || vuln.vulnerabilityType;
    if (!rules.has(ruleId)) {
      rules.set(ruleId, {
        id: ruleId,
        name: vuln.vulnerabilityType,
        shortDescription: {
          text: vuln.description,
        },
        fullDescription: {
          text: vuln.description,
        },
        help: {
          text: vuln.remediation || "",
        },
        properties: {
          security_severity: mapSeverityToScore(vuln.severity),
          tags: [vuln.cweId, vuln.owaspCategory].filter(Boolean),
        },
      });
    }
  }

  return Array.from(rules.values());
}

/**
 * é‡è¦åº¦ã‚’SARIFãƒ¬ãƒ™ãƒ«ã«ãƒãƒƒãƒ”ãƒ³ã‚°
 */
function mapSeverityToSarifLevel(severity: SecuritySeverityValue): string {
  switch (severity) {
    case "CRITICAL":
    case "HIGH":
      return "error";
    case "MEDIUM":
      return "warning";
    case "LOW":
      return "note";
    default:
      return "none";
  }
}

/**
 * é‡è¦åº¦ã‚’ã‚¹ã‚³ã‚¢ã«ãƒãƒƒãƒ”ãƒ³ã‚°
 */
function mapSeverityToScore(severity: SecuritySeverityValue): string {
  switch (severity) {
    case "CRITICAL":
      return "9.0";
    case "HIGH":
      return "7.0";
    case "MEDIUM":
      return "5.0";
    case "LOW":
      return "3.0";
    default:
      return "1.0";
  }
}
