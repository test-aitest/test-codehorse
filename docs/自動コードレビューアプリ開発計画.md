# **次世代AIコードレビュー自動化プラットフォーム構築のための技術的包括レポート：CodeRabbitアーキテクチャの進化と実装戦略**

## **1\. エグゼクティブサマリー**

現代のソフトウェア開発ライフサイクル（SDLC）において、コードレビューは品質保証の最後の砦であると同時に、開発速度を低下させる主要なボトルネックとなっています。本レポートは、既存のYouTubeリファレンス実装（通称「Code Horse」）1および市場をリードする「CodeRabbit」2のアーキテクチャを詳細に分析し、これらを超越するエンタープライズグレードの自動コードレビューSaaSアプリケーションを構築するための包括的な技術仕様書です。

本プロジェクトの核心は、単なるテキスト生成AIのラッパーを作成することではなく、GitHubのエコシステムと深く統合された「自律型コード品質エージェント」を構築することにあります。Next.js 16、Inngest、Pinecone、Google Gemini/OpenAIを基盤とし、octokit.js、tiktokenizer、p-limit、p-retryといった堅牢なライブラリ群を高度にオーケストレーションすることで、GitHub APIの厳格なレート制限4を遵守しつつ、大規模なコードベースに対してコンテキスト認識型のレビューを提供します。

本レポートは、AIコーディングエージェント「Claude Code」に対して、実装に必要な機能要件、技術的制約、データスキーマ、およびアルゴリズムロジックを正確に指示するための「マスタープラン」として機能します。単なる機能の列挙に留まらず、なぜその技術が必要なのか、どのようなエッジケース（境界条件）を考慮すべきかという第2次、第3次の洞察を含めて論じます。

## ---

**2\. 戦略的背景と既存実装の進化**

### **2.1 現状の課題とCodeRabbitの成功要因**

従来の手動コードレビューは、レビューアのスキル依存、疲労による見落とし、そしてフィードバックの遅延という構造的な問題を抱えています。CodeRabbitはこの課題に対し、大規模言語モデル（LLM）を用いて「コミットごとの増分レビュー」「自然言語による対話機能」「全体コンテキストの理解（RAG）」を提供することで成功を収めました2。特に、単なるLintツールの代替ではなく、シニアエンジニアのように「コードの意図」を理解し、アーキテクチャレベルの示唆を与える点が評価されています。

### **2.2 リファレンス実装（Code Horse）の分析と限界**

YouTubeで公開されているリファレンス実装1は、Next.jsとInngestを使用したイベント駆動アーキテクチャの優れた出発点を提供しています。しかし、プロフェッショナルなSaaSとして運用するには、以下の点で決定的な不足があります。

| 機能領域 | リファレンス実装 (Code Horse) | 目指すべき進化形 (Target Architecture) | 技術的ギャップと解決策 |
| :---- | :---- | :---- | :---- |
| **Github API制御** | 基本的な実装（レート制限への考慮不足） | **適応型レート制限と並行性制御** | p-limitとp-retryによるバースト制御と指数バックオフの実装 5。 |
| **コンテキスト理解** | 単純なRAG（ベクトル検索） | **AST解析とセマンティックチャンキング** | gitdiff-parserとtiktokenizerを用いた、トークン制限を意識した高度な分割ロジック 6。 |
| **大規模PR対応** | 不明（トークンオーバーフローのリスク） | **Map-Reduce要約パイプライン** | ファイルごとの要約（Map）と全体要約（Reduce）の多段階処理 8。 |
| **対話機能** | 限定的 | **マルチターンチャットボット** | issue\_commentイベントをフックし、スレッドコンテキストを保持した対話の実装 9。 |
| **UI/UX** | 基本的な管理画面 | **可観測性重視のダッシュボード** | Shadcn UIとRechartsを用いた、レビュー効率やバグ検出率の可視化 10。 |

このギャップを埋めるため、本プロジェクトでは「堅牢性（Reliability）」と「コンテキスト認識（Context Awareness）」を二大柱としてアーキテクチャを再設計します。

## ---

**3\. コアアーキテクチャと技術スタックの選定**

システム全体は、GitHubからのイベントをトリガーとする非同期・イベント駆動型のマイクロサービス構成（論理的構成）を採用します。Next.js 16のServer ActionsとAPI Routesをフロントドアとし、Inngestをバックボーンとして長時間実行タスクを管理します。

### **3.1 技術スタックの正当性評価**

1. **フレームワーク: Next.js 16 (App Router)**  
   * **選定理由:** Vercel AI SDKとの親和性が高く、ストリーミングレスポンスやServer ActionsによるDB操作が容易であるため1。  
2. **ジョブオーケストレーション: Inngest**  
   * **選定理由:** OpenAIやGeminiによるコード解析は数分を要する場合があり、通常のHTTPリクエスト（タイムアウト10〜60秒）では処理しきれません。Inngestは「Step Functions」を提供し、関数実行の途中で状態を保存しながら長時間待機（スリープ）や再試行が可能であるため、AIワークフローに最適です1。  
3. **ベクトルデータベース: Pinecone**  
   * **選定理由:** コードベース全体の知識（ドキュメント、依存関係）を検索可能にするRAG（Retrieval-Augmented Generation）を実現するため、高速かつスケーラブルなベクトル検索が必要です7。  
4. **認証: Better Auth / NextAuth**  
   * **選定理由:** GitHub OAuthとの統合が必須であり、セッション管理とセキュリティ（JWT）を堅牢に実装するため1。

## ---

**4\. GitHub統合レイヤー：堅牢性とレート制限の克服**

GitHub Appとしての統合は本システムの根幹ですが、最も脆弱になり得るポイントでもあります。APIの乱用検知（Abuse Detection）を回避し、大規模リポジトリでも安定して動作するためのロジックを構築します。

### **4.1 GitHub Appとしての認証戦略**

OAuth Appではなく、**GitHub App**として実装します。これにより、ユーザー個人ではなく「インストール（組織またはリポジトリ）」に紐付いた権限管理が可能となり、APIレート制限も緩和されます4。

* **権限スコープ:** pull\_requests: write（コメント投稿）、contents: read（コード取得）、metadata: read（リポジトリ情報）、issues: write（チャット応答）11。

### **4.2 p-limit と p-retry を用いた並行制御設計**

CodeRabbitのようなツールが直面する最大の課題は、数十〜数百のファイルを含むPRの処理です。Promise.allで全ファイルのコンテンツを一斉に取得しようとすると、GitHubのセカンダリレート制限（短時間の大量リクエスト）に抵触し、403エラーが発生します12。

#### **4.2.1 p-limit による並行性（Concurrency）の制限**

Node.jsのイベントループにおいて、非同期リクエストの「同時実行数」を物理的に制限する必要があります。

* 実装戦略:  
  octokitのリクエストを直接呼び出すのではなく、p-limitでラップした実行関数を経由させます。同時実行数は「5」程度に設定するのが安全圏です5。  
  TypeScript  
  import pLimit from 'p-limit';  
  // 同時実行数を5に制限（GitHubのAbuse Detection回避のため）  
  const limit \= pLimit(5);

  const fileContents \= await Promise.all(  
    files.map(file \=\> limit(() \=\>   
      octokit.rest.repos.getContent({   
        owner,   
        repo,   
        path: file.filename,   
        ref: commitSha   
      })  
    ))  
  );

  このパターンにより、例えば50ファイルの変更があっても、ネットワーク上には常に最大5つのリクエストしか飛ばない状態が維持され、サーバー負荷とAPI制限の両方をクリアします。

#### **4.2.2 p-retry による指数バックオフと障害回復**

ネットワークの一時的な瞬断や、GitHub側の一時的な5xxエラーに対応するため、p-retryを導入します。ここで重要なのは、単に再試行するのではなく、GitHubが返すRetry-Afterヘッダーやx-ratelimit-resetヘッダーを尊重することです13。

* **高度なリトライロジック:**  
  * **対象エラー:** 500系エラー、および429（Too Many Requests）。  
  * **待機時間:** デフォルトの指数バックオフに加え、429エラーの場合はレスポンスヘッダーのRetry-After値を解析し、その秒数分だけ待機してからリトライするカスタムロジックを注入します。  
  * **統合:** octokitにはプラグインエコシステム（@octokit/plugin-retry, @octokit/plugin-throttling）が存在しますが、Inngestのジョブ内での細かい制御を行うため、p-retryを用いた明示的なラッパー関数を実装することが推奨されます15。

### **4.3 Webhookのセキュリティと冪等性（Idempotency）**

GitHubからのWebhookは、ネットワークの都合で重複して送信される可能性があります。同じコミットに対して二重にレビューを行うことを防ぐため、データベースレベルでの冪等性担保が必要です。

* **署名検証:** X-Hub-Signature-256ヘッダーを使用し、Webhook Secretを用いてペイロードの正当性を検証します。  
* **処理済みチェック:** Inngestのジョブ開始時に、Reviewテーブルを照会し、当該commit\_shaに対するレビューが既にCOMPLETEDまたはPROCESSINGでないかを確認します16。

## ---

**5\. 認知エンジン：AI解析、トークン管理、RAG戦略**

「AIにコードを読ませる」プロセスは、単純なテキスト渡しでは機能しません。コンテキストウィンドウの制限、コスト、そして精度のバランスを取るための高度な前処理が必要です。

### **5.1 gitdiff-parser による構造化データの生成**

生のgit diff出力はテキストの塊であり、そのままではAIがファイル構造を理解しにくい場合があります。gitdiff-parser6を使用して、Diffを「ファイル」「ハンク（Hunk）」「変更行」のオブジェクトにパースします。

* **構造化の利点:**  
  * 特定のファイル（例: package-lock.jsonや自動生成ファイル）をプログラム的に除外可能。  
  * ハンクごとの行番号を正確に把握できるため、GitHub APIでインラインコメントを投稿する際のlineパラメータを正確に指定可能17。

### **5.2 tiktokenizer を用いた厳密なトークン計算**

LLM（GPT-4oやGemini 1.5 Pro）には入力トークン数の制限があります。また、従量課金であるため、無駄なコンテキスト送信はコストに直結します。

* 実装詳細:  
  tiktokenizer（OpenAIのtiktokenのラッパー等）を使用して、プロンプトに含める全テキストのトークン数を事前に計算します18。文字数ベースの概算ではなく、BPE（Byte Pair Encoding）に基づいた正確な計算を行うことで、APIエラー（Context Length Exceeded）を100%回避します。

### **5.3 大規模変更への対応：セマンティックチャンキングとMap-Reduce**

一度のPRで数千行の変更がある場合、単一のプロンプトには収まりません。ここで「チャンキング戦略」が重要になります7。

1. **チャンキング（分割）戦略:**  
   * **ファイル単位:** 基本単位。  
   * **ハンク単位:** ファイルが巨大な場合、変更箇所（ハンク）ごとに分割。  
   * **Map処理:** 分割された各チャンクを並列にLLMに送信し、「この部分のバグと改善点を指摘せよ」というタスクを実行させます。  
2. **Reduce処理:**  
   * 各チャンクからのレビュー結果を集約し、重複を排除した後、最終的な「PR全体のサマリー」を生成する別のLLMコールを行います8。これにより、局所的な指摘と大局的な要約の両立を実現します。

### **5.4 Pineconeを用いたRAG（検索拡張生成）**

CodeRabbitの強みは「変更されていないコード」も理解している点にあります。これを実現するのがRAGです1。

* **インデックス構築:** リポジトリが連携された時点、およびmainブランチへのマージ時点で、コードベース全体をクロールし、関数やクラス単位でベクトル化（Embeddings）してPineconeに保存します。  
* **検索ロジック:** PR内の変更コードをクエリとしてPineconeを検索し、関連性の高い既存コード（定義元や依存先）を抽出します。  
* **コンテキスト注入:** 抽出したコードをシステムプロンプトの「関連コンテキスト」セクションに挿入します。これにより、AIは「この変更がutils.tsの関数Aに依存しており、その仕様に違反している」といった高度な指摘が可能になります。

## ---

**6\. プロンプトエンジニアリングとペルソナ設計**

AIの出力品質はプロンプトに依存します。CodeRabbitのような「有能なレビュアー」を再現するためのプロンプト設計を行います21。

### **6.1 システムプロンプトの構成**

* **ペルソナ定義:** 「あなたはGoogle、Meta、Amazonでの経験を持つシニアプリンシパルエンジニアです。コードの安全性、パフォーマンス、保守性を最優先します。」  
* **トーン設定:** .coderabbit.yamlの設定に基づき、「Chill（親しみやすい）」や「Assertive（断定的）」に切り替えます22。  
* **制約事項:**  
  * 「一般的な賞賛（Good jobなど）は不要。」  
  * 「自明なこと（変数が定義されました等）は説明しない。」  
  * 「指摘は具体的かつ実用的なコード修正案を含むこと。」  
  * 「JSON形式で出力すること。」

### **6.2 構造化出力（Structured Output）**

AIからのレスポンスは自由テキストではなく、Zodスキーマ等で定義されたJSONオブジェクトとして受け取ります。これにより、アプリケーション側で「どのファイルの何行目にコメントするか」を確実にパースできます。

JSON

{  
  "summary": "認証ロジックのリファクタリングにより、トークン検証の脆弱性が解消されました...",  
  "comments":  
}

## ---

**7\. データベース設計とPrismaスキーマ**

アプリケーションの状態管理には、リレーショナルデータベース（PostgreSQL）とORM（Prisma）を使用します。GitHubのデータ構造とアプリケーションの要件をマッピングした詳細なスキーマが必要です23。

### **7.1 主要テーブル構成**

| モデル名 | 役割 | 主要フィールドとリレーション |
| :---- | :---- | :---- |
| **User** | ユーザー管理 | githubId, email, repositories (One-to-Many), subscriptions |
| **Repository** | リポジトリ設定 | owner, name, installationId (GitHub App ID), config (YAML設定のキャッシュ), vectorsIndexed (RAG状態) |
| **PullRequest** | PR状態管理 | number, repoId, baseSha, headSha, title, status |
| **Review** | レビュー履歴 | prId, status (PENDING, COMPLETED), summary (AI生成要約) |
| **ReviewComment** | 個別指摘 | reviewId, filePath, lineNumber, body, severity, aiGenerated |

特にRepositoryモデルのconfigフィールドは、リポジトリごとの.coderabbit.yamlの内容をJSONとしてキャッシュし、レビューの度にフェッチするオーバーヘッドを削減するために重要です24。

## ---

**8\. プロフェッショナルUI/UXの実装**

プロフェッショナルなツールとして認知されるためには、管理画面（ダッシュボード）の品質が重要です。Shadcn UIとTailwind CSSを採用し、モダンでアクセシブルなUIを構築します1。

### **8.1 ダッシュボード機能要件**

1. **リポジトリ一覧とステータス:**  
   * 連携済みリポジトリのカード表示。  
   * RAGインデックス作成状況のプログレスバー表示（Inngestからのイベントでリアルタイム更新）。  
2. **分析（Analytics）タブ:**  
   * Rechartsを使用したグラフ表示。  
   * 「週間PR数」「AIによるバグ検出数」「削減されたレビュー時間（推定）」などのKPIを可視化25。これにより、ユーザー（エンジニアリングマネージャー）にツールのROIを証明します。  
3. **設定エディタ（YAML Generator）:**  
   * .coderabbit.yamlを手書きせずに生成できるGUIフォーム。  
   * 「除外ファイルパターン」「言語設定」「トーン設定」をスイッチや入力フィールドで操作し、最終的なYAMLをコピーまたはPRとして発行する機能26。

### **8.2 チャットボットUI（GitHub上）**

GitHubのPRコメント欄での対話機能は、Webhooksのissue\_commentイベントをトリガーに機能します。

* **UXフロー:** ユーザーがAIの指摘コメントに「これどういう意味？もっと詳しく」と返信 \-\> Webhook発火 \-\> AIがスレッドコンテキストを読み取り \-\> そのスレッドに返信コメントを投稿。  
* **アイコンとブランディング:** AIのコメントには専用のボットアイコンと「Generated by AI」のバッジを付与し、人間との区別を明確にします。

## ---

**9\. 「Claude Code」への実装指示書（スペックシート）**

本レポートの結論として、AIコーディングエージェント（Claude Code）に渡すべき具体的な実装指示をまとめます。

### **9.1 プロジェクト初期化**

* **コマンド:** npx create-next-app@latest \--typescript \--tailwind \--eslint  
* **依存関係:** npm install inngest octokit @octokit/plugin-retry tiktokenizer p-limit p-retry gitdiff-parser @prisma/client pinecone-client ai zod

### **9.2 ディレクトリ構造の指定**

src/  
├── app/  
│   ├── api/  
│   │   ├── inngest/route.ts      \# ジョブワーカーのエントリーポイント  
│   │   └── webhooks/github/route.ts \# GitHubからのイベント受信  
├── lib/  
│   ├── github/  
│   │   ├── client.ts             \# p-limit/retryを含むOctokitラッパー  
│   │   └── diff.ts               \# gitdiff-parserとtiktokenizerの実装  
│   ├── ai/  
│   │   ├── rag.ts                \# Pinecone検索・登録ロジック  
│   │   └── review.ts             \# Vercel AI SDK呼び出し  
│   └── prisma.ts  
├── inngest/  
│   ├── client.ts  
│   └── functions/  
│       ├── pr-review.ts          \# メインのレビューフロー  
│       └── repo-index.ts         \# RAG用インデックス作成フロー

### **9.3 重要な実装制約（Claudeへの指示）**

1. **レート制限の厳守:** GitHub API呼び出しは必ずsrc/lib/github/client.tsで定義したlimit()関数を経由させること。直接octokitを呼ばないこと。  
2. **トークン計算:** AIにプロンプトを投げる前に必ずtiktokenizerでカウントし、モデルの最大トークン（例: 128k）を超える場合はチャンキングロジックを起動させること。  
3. **型安全性:** GitHub APIのレスポンス型（GetContentResponseなど）は@octokit/typesを使用し、anyを避けること。  
4. **エラーハンドリング:** Webhookハンドラーは、検証エラー以外は常に200を返し、処理はInngestにオフロードすること（タイムアウト防止）。

## ---

**10\. 結論**

本レポートで提示したアーキテクチャは、既存のCodeRabbitクローンチュートリアルを大きく超え、実際の商用環境（SaaS）で運用可能なレベルの信頼性と機能性を備えています。特にp-limitによる並行制御、tiktokenizerによる厳密なコンテキスト管理、そしてInngestによる堅牢なジョブ実行基盤は、プロフェッショナルなツールとして不可欠な要素です。この青写真に基づき開発を進めることで、開発者の生産性を真に向上させる次世代のAIコードレビュープラットフォームが実現します。

#### **引用文献**

1. I Built an AI Code Review SaaS with Next.js 16 Pinecone RAG Gemini AI Inngest Better Auth Polar, 12月 25, 2025にアクセス、 [https://www.youtube.com/watch?v=my29RqLL-vg](https://www.youtube.com/watch?v=my29RqLL-vg)  
2. AI Code Reviews | CodeRabbit | Try for Free, 12月 25, 2025にアクセス、 [https://www.coderabbit.ai/](https://www.coderabbit.ai/)  
3. CodeRabbit Documentation \- AI code reviews on pull requests, IDE, and CLI, 12月 25, 2025にアクセス、 [https://docs.coderabbit.ai/](https://docs.coderabbit.ai/)  
4. Rate limits for GitHub Apps, 12月 25, 2025にアクセス、 [https://docs.github.com/en/apps/creating-github-apps/registering-a-github-app/rate-limits-for-github-apps](https://docs.github.com/en/apps/creating-github-apps/registering-a-github-app/rate-limits-for-github-apps)  
5. Controlled Concurrency with Retries in Node.js using p-limit | by Shubham Soni \- Medium, 12月 25, 2025にアクセス、 [https://medium.com/@sonishubham65/controlled-concurrency-with-retries-in-node-js-using-p-limit-063159ab8478](https://medium.com/@sonishubham65/controlled-concurrency-with-retries-in-node-js-using-p-limit-063159ab8478)  
6. gitdiff-parser \- NPM, 12月 25, 2025にアクセス、 [http://www.npmjs.com/package/gitdiff-parser](http://www.npmjs.com/package/gitdiff-parser)  
7. Chunking Strategies for LLM Applications \- Pinecone, 12月 25, 2025にアクセス、 [https://www.pinecone.io/learn/chunking-strategies/](https://www.pinecone.io/learn/chunking-strategies/)  
8. Dueling AIs: AI reviewing AI generated code : r/github \- Reddit, 12月 25, 2025にアクセス、 [https://www.reddit.com/r/github/comments/15cty8a/dueling\_ais\_ai\_reviewing\_ai\_generated\_code/](https://www.reddit.com/r/github/comments/15cty8a/dueling_ais_ai_reviewing_ai_generated_code/)  
9. octokit \- . \- pulls \- GitHub Pages, 12月 25, 2025にアクセス、 [https://actions-cool.github.io/octokit-rest/api/pulls/](https://actions-cool.github.io/octokit-rest/api/pulls/)  
10. 156 SaaS Dashboard Design Examples in 2025 \- SaaSFrame, 12月 25, 2025にアクセス、 [https://www.saasframe.io/categories/dashboard](https://www.saasframe.io/categories/dashboard)  
11. Webhook events and payloads \- GitHub Docs, 12月 25, 2025にアクセス、 [https://docs.github.com/en/webhooks/webhook-events-and-payloads](https://docs.github.com/en/webhooks/webhook-events-and-payloads)  
12. Where can I view the secondary rate limit of GitHub REST api? \- Stack Overflow, 12月 25, 2025にアクセス、 [https://stackoverflow.com/questions/73644164/where-can-i-view-the-secondary-rate-limit-of-github-rest-api](https://stackoverflow.com/questions/73644164/where-can-i-view-the-secondary-rate-limit-of-github-rest-api)  
13. Add support for retries · Issue \#71 · actions/create-github-app-token, 12月 25, 2025にアクセス、 [https://github.com/actions/create-github-app-token/issues/71](https://github.com/actions/create-github-app-token/issues/71)  
14. Dealing with GitHub's rate limiting · Issue \#855 · peter-evans/create-pull-request, 12月 25, 2025にアクセス、 [https://github.com/peter-evans/create-pull-request/issues/855](https://github.com/peter-evans/create-pull-request/issues/855)  
15. Throttling, 12月 25, 2025にアクセス、 [https://actions-cool.github.io/octokit-rest/en-US/guide/09\_throttling/](https://actions-cool.github.io/octokit-rest/en-US/guide/09_throttling/)  
16. GitHub Webhooks: Complete Guide with Event Examples, 12月 25, 2025にアクセス、 [https://www.magicbell.com/blog/github-webhooks-guide](https://www.magicbell.com/blog/github-webhooks-guide)  
17. REST API endpoints for pull request review comments \- GitHub Docs, 12月 25, 2025にアクセス、 [https://docs.github.com/rest/pulls/comments](https://docs.github.com/rest/pulls/comments)  
18. dqbd/tiktokenizer: Online playground for OpenAPI tokenizers \- GitHub, 12月 25, 2025にアクセス、 [https://github.com/dqbd/tiktokenizer](https://github.com/dqbd/tiktokenizer)  
19. Yash8745/Chunking\_RAG: Comparing And Analizing Different Chunking Strategies for different Usecases \- GitHub, 12月 25, 2025にアクセス、 [https://github.com/Yash8745/Chunking\_RAG](https://github.com/Yash8745/Chunking_RAG)  
20. 25 chunking tricks for RAG that devs actually use | by  
21. ai-pr-reviewer/src/prompts.ts at main · coderabbitai/ai-pr-reviewer \- GitHub, 12月 25, 2025にアクセス、 [https://github.com/coderabbitai/ai-pr-reviewer/blob/main/src/prompts.ts](https://github.com/coderabbitai/ai-pr-reviewer/blob/main/src/prompts.ts)  
22. Official awesome-list of CodeRabbit Starters & Resources ⚡️ \- GitHub, 12月 25, 2025にアクセス、 [https://github.com/coderabbitai/awesome-coderabbit](https://github.com/coderabbitai/awesome-coderabbit)  
23. What is Prisma ORM? (Overview), 12月 25, 2025にアクセス、 [https://www.prisma.io/docs/orm/overview/introduction/what-is-prisma](https://www.prisma.io/docs/orm/overview/introduction/what-is-prisma)  
24. Configuration via YAML File \- CodeRabbit Documentation \- AI code reviews on pull requests, IDE, and CLI, 12月 25, 2025にアクセス、 [https://docs.coderabbit.ai/getting-started/yaml-configuration](https://docs.coderabbit.ai/getting-started/yaml-configuration)  
25. Monitoring code review metrics to improve team performance \- Graphite, 12月 25, 2025にアクセス、 [https://graphite.com/guides/monitoring-code-review-metrics-team-performance](https://graphite.com/guides/monitoring-code-review-metrics-team-performance)  
26. YAML validator \- CodeRabbit Documentation \- AI code reviews on pull requests, IDE, and CLI, 12月 25, 2025にアクセス、 [https://docs.coderabbit.ai/configuration/yaml-validator](https://docs.coderabbit.ai/configuration/yaml-validator)